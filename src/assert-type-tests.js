// Generated by CoffeeScript 1.9.3
(function() {
  var _, expect, ty, util;

  expect = require('expect.js');

  ty = require('./assert-type');

  _ = require('underscore');

  util = require('util');

  describe('simple types', function() {
    var simpleTest;
    simpleTest = function(tc, pos, neg) {
      pos.forEach(function(x) {
        var err;
        try {
          return expect(tc(x)).to.be(true);
        } catch (_error) {
          err = _error;
          err.message = x + " failed but should have passed";
          throw err;
        }
      });
      return neg.forEach(function(x) {
        var err;
        try {
          return expect(tc(x)).to.be(false);
        } catch (_error) {
          err = _error;
          err.message = x + " passed but should have failed";
          throw err;
        }
      });
    };
    it('- bool', function() {
      return simpleTest(ty.bool, [true, false], [
        void 0, null, {}, [], NaN, 0, 12345, 3.14, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- num', function() {
      return simpleTest(ty.num, [NaN, 0, 12345, 3.14, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY], [
        void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- num.not.nan', function() {
      return simpleTest(ty.num.not.nan, [0, 12345, 3.14, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY], [
        NaN, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- num.pos', function() {
      return simpleTest(ty.num.pos, [1, 1.1, Number.POSITIVE_INFINITY], [
        0, -1, Number.NEGATIVE_INFINITY, NaN, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- num.neg', function() {
      return simpleTest(ty.num.neg, [-1, -1.1, Number.NEGATIVE_INFINITY], [
        0, 1, Number.POSITIVE_INFINITY, NaN, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- num.nonneg', function() {
      return simpleTest(ty.num.nonneg, [0, 1, 0.1, Number.POSITIVE_INFINITY], [
        -1, Number.NEGATIVE_INFINITY, NaN, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- num.finite', function() {
      return simpleTest(ty.num.finite, [-1, 0, 12345, 3.14], [
        NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- num.finite.pos', function() {
      return simpleTest(ty.num.finite.pos, [1, 1.1], [
        0, -1, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, NaN, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- num.finite.neg', function() {
      return simpleTest(ty.num.finite.neg, [-1, -1.1], [
        0, 1, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, NaN, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- num.finite.nonneg', function() {
      return simpleTest(ty.num.finite.nonneg, [0, 1, 0.1], [
        -1, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, NaN, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- int.pos', function() {
      return simpleTest(ty.int.pos, [1, 12345], [
        0, -1, -2.71, 3.14, NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- int.neg', function() {
      return simpleTest(ty.int.neg, [-1, -12345], [
        0, 1, -2.71, 3.14, NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- int.nonneg', function() {
      return simpleTest(ty.int.nonneg, [0, 1, 12345], [
        -1, -2.71, 3.14, NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, void 0, null, {}, [], true, false, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- str', function() {
      return simpleTest(ty.str, ['', 'foo'], [
        void 0, null, {}, [], true, false, NaN, 0, 12345, 3.14, (function() {
          return 0;
        })
      ]);
    });
    it('- str.ne', function() {
      return simpleTest(ty.str.ne, ['foo'], [
        '', false, void 0, null, {}, [], true, false, NaN, 0, 12345, 3.14, (function() {
          return 0;
        })
      ]);
    });
    it('- arr', function() {
      return simpleTest(ty.arr, [[], [0], [0, 1]], [
        void 0, null, {}, true, false, NaN, 0, -1, 3.14, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- arr.ne', function() {
      return simpleTest(ty.arr.ne, [[0], [0, 1]], [
        [], void 0, null, {}, true, false, NaN, 0, -1, 3.14, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- obj', function() {
      return simpleTest(ty.obj, [null, {}, []], [
        false, void 0, NaN, 0, -1, 3.14, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- obj.not.null', function() {
      return simpleTest(ty.obj.not["null"], [{}, []], [
        null, false, void 0, NaN, 0, -1, 3.14, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- null', function() {
      return simpleTest(ty["null"], [null], [
        {}, [], false, void 0, NaN, 0, -1, 3.14, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- undefined', function() {
      return simpleTest(ty.undefined, [void 0], [
        {}, [], false, null, NaN, 0, -1, 3.14, '', 'foo', (function() {
          return 0;
        })
      ]);
    });
    it('- fun', function() {
      return simpleTest(ty.fun, [
        function() {
          return 0;
        }
      ], [{}, [], false, void 0, null, NaN, 0, -1, 3.14, '', 'foo']);
    });
    return it('- any', function() {
      return simpleTest(ty.any, [
        void 0, null, {}, [], true, false, NaN, 0, 12345, 3.14, '', 'foo', (function() {
          return 0;
        })
      ], []);
    });
  });

  describe('Assert', function() {
    describe('single', function() {
      it('positive', function() {
        expect(ty.Assert(ty.bool)(true)).to.be(true);
        expect(ty.Assert(ty.bool)(false)).to.be(false);
        expect(ty.Assert(ty.any)(void 0)).to.be(void 0);
        return expect(ty.Assert(ty.any)(null)).to.be(null);
      });
      it('negative', function() {
        return [
          void 0, null, {}, [], NaN, 0, 12345, 3.14, '', 'foo', (function() {
            return 0;
          })
        ].forEach(function(x) {
          return expect(function() {
            return ty.Assert(ty.bool(x));
          }).to.throwError();
        });
      });
      return it('wrong', function() {
        return [
          void 0, null, {}, [], NaN, 0, 12345, 3.14, '', 'foo', (function() {
            return 0;
          })
        ].forEach(function(x) {
          return expect(function() {
            return ty.Assert(x);
          }).to.throwError();
        });
      });
    });
    describe('multi', function() {
      it('positive', function() {
        return expect(ty.Assert(ty.bool, ty.int)(true, 0)).to.eql([true, 0]);
      });
      it('negative', function() {
        return expect(function() {
          return ty.Assert(ty.bool, ty.int)(true, false);
        }).to.throwError();
      });
      return it('wrong', function() {
        expect(function() {
          return ty.Assert();
        }).to.throwError();
        return [
          void 0, null, {}, [], NaN, 0, 12345, 3.14, '', 'foo', (function() {
            return 0;
          })
        ].forEach(function(x) {
          expect(function() {
            return ty.Assert(ty.bool, x);
          }).to.throwError();
          return expect(function() {
            return ty.Assert(x, ty.bool);
          }).to.throwError();
        });
      });
    });
    return it('error type & message', function() {
      var err;
      try {
        ty.Assert(ty.bool)(0);
        return expect().fail();
      } catch (_error) {
        err = _error;
        expect(err instanceof ty.TypeAssertionError).to.be(true);
        expect(err.toString()).to.be("TypeAssertionError: expected boolean");
        expect(err.message).to.be("expected boolean");
        expect(err.expected).to.be("boolean");
        return expect(err.actual).to.be(0);
      }
    });
  });

  describe("'or'", function() {
    it('positive', function() {
      expect(ty.or(ty.bool, ty.num)(true)).to.be(true);
      return expect(ty.or(ty.bool, ty.num)(0)).to.be(true);
    });
    it('negative', function() {
      return [
        void 0, null, {}, '', 'foo', (function() {
          return 0;
        })
      ].forEach(function(x) {
        return expect(ty.or(ty.bool, ty.num)(x)).to.be(false);
      });
    });
    return it('wrong', function() {
      expect(function() {
        return ty.or();
      }).to.throwError();
      return [
        void 0, null, {}, NaN, 0, 12345, 3.14, '', 'foo', (function() {
          return 0;
        })
      ].forEach(function(x) {
        expect(function() {
          return ty.or(x);
        }).to.throwError();
        return expect(function() {
          return ty.or(ty.int, x);
        }).to.throwError();
      });
    });
  });

  describe('funN', function() {
    it('positive', function() {
      expect(ty.funN(0)(function() {
        return 0;
      })).to.be(true);
      return expect(ty.funN(2)(function(x, y) {
        return x;
      })).to.be(true);
    });
    it('negative', function() {
      expect(ty.funN(0)(function(x) {
        return x;
      })).to.be(false);
      expect(ty.funN(1)(function() {
        return 0;
      })).to.be(false);
      expect(ty.funN(2)(function(x) {
        return x;
      })).to.be(false);
      return [
        void 0, null, {}, NaN, 0, 12345, 3.14, '', 'foo', (function() {
          return 0;
        })
      ].forEach(function(x) {
        return expect(ty.funN(1)(x)).to.be(false);
      });
    });
    return it('wrong', function() {
      expect(function() {
        return ty.funN();
      }).to.throwError();
      return [
        void 0, null, {}, NaN, -1, 3.14, '', 'foo', (function() {
          return 0;
        })
      ].forEach(function(x) {
        return expect(function() {
          return ty.funN(x);
        }).to.throwError();
      });
    });
  });

  describe('arr.of', function() {
    describe('one type', function() {
      it('positive', function() {
        expect(ty.arr.of(ty.bool)([])).to.be(true);
        expect(ty.arr.of(ty.bool)([true])).to.be(true);
        return expect(ty.arr.of(ty.bool)([true, false])).to.be(true);
      });
      it('negative', function() {
        expect(ty.arr.of(ty.bool)([0])).to.be(false);
        expect(ty.arr.of(ty.bool)([0, true])).to.be(false);
        return expect(ty.arr.of(ty.bool)([true, false, 0])).to.be(false);
      });
      return it('wrong', function() {
        return [
          void 0, null, {}, NaN, 0, 12345, 3.14, '', 'foo', (function() {
            return 0;
          })
        ].forEach(function(x) {
          return expect(function() {
            return ty.arr.of(x);
          }).to.throwError();
        });
      });
    });
    return describe('array of types', function() {
      it('positive', function() {
        expect(ty.arr.of([])([])).to.be(true);
        expect(ty.arr.of([ty.bool])([true])).to.be(true);
        return expect(ty.arr.of([ty.bool, ty.int])([true, 0])).to.be(true);
      });
      return it('negative', function() {
        expect(ty.arr.of([])([true])).to.be(false);
        expect(ty.arr.of([ty.bool])([])).to.be(false);
        expect(ty.arr.of([ty.bool])([0])).to.be(false);
        expect(ty.arr.of([ty.bool])([0, 0])).to.be(false);
        expect(ty.arr.of([ty.bool, ty.int])([0])).to.be(false);
        expect(ty.arr.of([ty.bool, ty.int])([0, 0])).to.be(false);
        expect(ty.arr.of([ty.bool, ty.int])([0, 0])).to.be(false);
        return [
          void 0, null, {}, [], NaN, 0, 12345, 3.14, '', 'foo', (function() {
            return 0;
          })
        ].forEach(function(x) {
          return expect(ty.arr.of([ty.bool, ty.int])(x)).to.be(false);
        });
      });
    });
  });

  describe('arr.ne.of', function() {
    it('positive', function() {
      expect(ty.arr.ne.of(ty.bool)([true])).to.be(true);
      return expect(ty.arr.ne.of(ty.bool)([true, false])).to.be(true);
    });
    it('negative', function() {
      expect(ty.arr.ne.of(ty.bool)([])).to.be(false);
      expect(ty.arr.ne.of(ty.bool)([0])).to.be(false);
      expect(ty.arr.ne.of(ty.bool)([0, true])).to.be(false);
      return expect(ty.arr.ne.of(ty.bool)([true, false, 0])).to.be(false);
    });
    return it('wrong', function() {
      return [
        void 0, null, {}, [], NaN, 0, 12345, 3.14, '', 'foo', (function() {
          return 0;
        })
      ].forEach(function(x) {
        return expect(function() {
          return ty.arr.ne.of(x);
        }).to.throwError();
      });
    });
  });

  describe('obj.of', function() {
    it('positive', function() {
      expect(ty.obj.of({})({})).to.be(true);
      return expect(ty.obj.of({
        x: ty.bool,
        y: ty.int
      })({
        x: true,
        y: 0
      })).to.be(true);
    });
    it('negative', function() {
      expect(ty.obj.of({})({
        x: true
      })).to.be(false);
      expect(ty.obj.of({
        x: ty.bool
      })({})).to.be(false);
      expect(ty.obj.of({
        x: ty.bool
      })({
        x: 0
      })).to.be(false);
      expect(ty.obj.of({
        x: ty.bool
      })({
        x: true,
        y: 0
      })).to.be(false);
      expect(ty.obj.of({
        x: ty.bool,
        y: ty.int
      })({
        x: true
      })).to.be(false);
      expect(ty.obj.of({
        x: ty.bool,
        y: ty.int
      })({
        x: 0,
        y: 0
      })).to.be(false);
      expect(ty.obj.of({
        x: ty.bool,
        y: ty.int
      })({
        x: true,
        y: false
      })).to.be(false);
      expect(ty.obj.of({
        x: ty.bool,
        y: ty.int
      })({
        x: 0,
        y: false
      })).to.be(false);
      return expect(ty.obj.of({
        x: ty.bool,
        y: ty.int
      })({
        x: true,
        z: 0
      })).to.be(false);
    });
    return it('wrong', function() {
      return [
        void 0, null, NaN, 0, 12345, 3.14, '', 'foo', (function() {
          return 0;
        })
      ].forEach(function(x) {
        return expect(function() {
          return ty.obj.of(x);
        }).to.throwError();
      });
    });
  });

  describe('obj.with', function() {
    it('positive', function() {
      expect(ty.obj["with"]({})({})).to.be(true);
      expect(ty.obj["with"]({})({
        x: true
      })).to.be(true);
      expect(ty.obj["with"]({
        x: ty.bool,
        y: ty.int
      })({
        x: true,
        y: 0
      })).to.be(true);
      return expect(ty.obj["with"]({
        x: ty.bool,
        y: ty.int
      })({
        x: true,
        y: 0,
        z: null
      })).to.be(true);
    });
    it('negative', function() {
      expect(ty.obj["with"]({
        x: ty.bool
      })({})).to.be(false);
      expect(ty.obj["with"]({
        x: ty.bool
      })({
        x: 0
      })).to.be(false);
      expect(ty.obj["with"]({
        x: ty.bool,
        y: ty.int
      })({
        x: true
      })).to.be(false);
      expect(ty.obj["with"]({
        x: ty.bool,
        y: ty.int
      })({
        x: 0,
        y: 0
      })).to.be(false);
      expect(ty.obj["with"]({
        x: ty.bool,
        y: ty.int
      })({
        x: true,
        y: false
      })).to.be(false);
      expect(ty.obj["with"]({
        x: ty.bool,
        y: ty.int
      })({
        x: 0,
        y: false
      })).to.be(false);
      return expect(ty.obj["with"]({
        x: ty.bool,
        y: ty.int
      })({
        x: true,
        z: 0
      })).to.be(false);
    });
    return it('wrong', function() {
      return [
        void 0, null, NaN, 0, 12345, 3.14, '', 'foo', (function() {
          return 0;
        })
      ].forEach(function(x) {
        return expect(function() {
          return ty.obj["with"](x);
        }).to.throwError();
      });
    });
  });

  describe('WrapFun', function() {
    var F;
    F = ty.WrapFun;
    it('positive', function() {
      expect(F([], ty.int, (function() {
        return 0;
      }))()).to.be(0);
      expect(F([ty.bool], ty.int, (function(x) {
        return 0;
      }))(true)).to.be(0);
      expect(F([ty.bool], ty.int, (function(x) {
        return 0;
      }))(false)).to.be(0);
      expect(F([ty.bool, ty.num], ty.arr, (function(x, y) {
        return [x, y];
      }))(true, 0)).to.eql([true, 0]);
      expect(F(ty.fun.of([], ty.int), (function() {
        return 0;
      }))()).to.be(0);
      expect(F(ty.fun.of([ty.bool], ty.int), (function(x) {
        return 0;
      }))(true)).to.be(0);
      expect(F(ty.fun.of([ty.bool], ty.int), (function(x) {
        return 0;
      }))(false)).to.be(0);
      return expect(F(ty.fun.of([ty.bool, ty.num], ty.arr), (function(x, y) {
        return [x, y];
      }))(true, 0)).to.eql([true, 0]);
    });
    it('negative', function() {
      expect(function() {
        return F([], ty.int, (function() {
          return true;
        })());
      }).to.throwError();
      expect(function() {
        return F([], ty.int, (function() {
          return true;
        })(null));
      }).to.throwError();
      expect(function() {
        return F([ty.bool], ty.int, (function(x) {
          return 0;
        }))();
      }).to.throwError();
      expect(function() {
        return F([ty.bool], ty.int, (function(x) {
          return 0;
        }))(true, null);
      }).to.throwError();
      expect(function() {
        return F([ty.bool], ty.int, (function(x) {
          return 0;
        }))(null);
      }).to.throwError();
      expect(function() {
        return F([ty.bool], ty.int, (function(x) {
          return null;
        }))(true);
      }).to.throwError();
      expect(function() {
        return F([ty.bool, ty.num], ty.int, (function(x) {
          return 0;
        }));
      }).to.throwError();
      expect(function() {
        return F([ty.bool, ty.num], ty.int, (function(x, y) {
          return 0;
        }))(true);
      }).to.throwError();
      expect(function() {
        return F([ty.bool, ty.num], ty.int, (function(x, y) {
          return 0;
        }))(0);
      }).to.throwError();
      expect(function() {
        return F([ty.bool, ty.num], ty.int, (function(x, y) {
          return 0;
        }))(true, null);
      }).to.throwError();
      expect(function() {
        return F([ty.bool, ty.num], ty.int, (function(x, y) {
          return 0;
        }))(null, 0);
      }).to.throwError();
      expect(function() {
        return F([ty.bool, ty.num], ty.int, (function(x, y) {
          return 0;
        }))(null, null);
      }).to.throwError();
      expect(function() {
        return F([ty.bool, ty.num], ty.int, (function(x, y) {
          return null;
        }))(true, 0);
      }).to.throwError();
      expect(function() {
        return F([ty.bool, ty.num], ty.int, (function(x, y) {
          return 0;
        }))(true, 0, 1);
      }).to.throwError();
      expect(function() {
        return F(ty.fun.of([ty.bool], ty.int), (function(x) {
          return 0;
        }))();
      }).to.throwError();
      return expect(function() {
        return F(ty.fun.of([ty.bool], ty.int), (function(x) {
          return 0;
        }))(null);
      }).to.throwError();
    });
    return it('wrong', function() {
      [
        void 0, null, {}, [], NaN, 0, 12345, 3.14, '', 'foo', (function() {
          return 0;
        })
      ].forEach(function(x) {
        if (!_.isArray(x)) {
          expect(function() {
            return F(x, ty.int, (function(x) {
              return 0;
            }));
          }).to.throwError();
        }
        expect(function() {
          return F([], x, (function(x) {
            return 0;
          }));
        }).to.throwError();
        return expect(function() {
          return F([ty.defined], ty.int, x)();
        }).to.throwError();
      });
      return expect(function() {
        return F(ty.int, (function(x) {
          return 0;
        }));
      }).to.throwError();
    });
  });

  describe('inst.of', function() {
    var Test;
    Test = (function() {
      function Test() {}

      return Test;

    })();
    it('positive', function() {
      return expect(ty.inst.of(Test)(new Test)).to.be(true);
    });
    return it('negative', function() {
      expect(ty.inst.of(Test)(0)).to.be(false);
      expect(ty.inst.of(Test)(null)).to.be(false);
      expect(ty.inst.of(Test)([])).to.be(false);
      expect(ty.inst.of(Test)({})).to.be(false);
      expect(ty.inst.of(Test)(0.12)).to.be(false);
      expect(ty.inst.of(Test)('')).to.be(false);
      expect(ty.inst.of(Test)('Foo')).to.be(false);
      expect(ty.inst.of(Test)(true)).to.be(false);
      return expect(ty.inst.of(Test)(false)).to.be(false);
    });
  });

  describe('fun.of', function() {
    var F;
    F = ty.WrapFun;
    it('positive', function() {
      expect(ty.fun.of([], ty.int)(F([], ty.int, (function() {
        return 0;
      })))).to.be(true);
      return expect(ty.fun.of([ty.bool], ty.int)(F([ty.bool], ty.int, (function(x) {
        return 0;
      })))).to.be(true);
    });
    it('negative', function() {
      expect(ty.fun.of([], ty.int)(F([ty.bool], ty.int, (function(b) {
        return 0;
      })))).to.be(false);
      expect(ty.fun.of([ty.bool], ty.int)(F([], ty.int, (function() {
        return 0;
      })))).to.be(false);
      return expect(ty.fun.of([], ty.int)(F([], ty.bool, (function() {
        return false;
      })))).to.be(false);
    });
    it('wrong', function() {
      [
        void 0, null, {}, [], NaN, 0, 12345, 3.14, '', 'foo', (function() {
          return 0;
        })
      ].forEach(function(x) {
        if (!_.isArray(x)) {
          expect(function() {
            return ty.fun.of(x, ty.int);
          }).to.throwError();
        }
        return expect(function() {
          return ty.fun.of([], x);
        }).to.throwError();
      });
      return expect(function() {
        return ty.fun.of(ty.int, ty.bool);
      }).to.throwError();
    });
    return describe('fixed-point combinator', function() {
      it('(weakly typed)', function() {
        var Z, hZ;
        hZ = (function(y) {
          return function(f) {
            return function(x) {
              return f(y(y)(f), x);
            };
          };
        });
        Z = F([ty.fun], ty.fun, hZ(hZ));
        return Z(function(rec, x) {
          if (x < 10) {
            return rec(x + 1);
          } else {
            return x;
          }
        })(0);
      });
      return it('(strongly typed)', function() {
        var Z, ft1, ft2, ftI, ftO, hZ;
        ftO = ty.fun.of([ty.any], ty.any);
        ftI = ty.fun.of([ftO, ty.any], ty.any);
        ft1 = ty.fun.of([ftI], ftO);
        ft2 = ty.fun.of([ty.fun], ft1);
        hZ = F(ft2, (function(y) {
          return F(ft1, (function(f) {
            return F(ftO, (function(x) {
              return f(y(y)(f), x);
            }));
          }));
        }));
        Z = hZ(hZ);
        return Z(F([ftO, ty.any], ty.any, (function(rec, x) {
          if (x < 10) {
            return rec(x + 1);
          } else {
            return x;
          }
        })))(0);
      });
    });
  });

  describe('WrapFun_', function(masterkont) {
    var F_;
    F_ = ty.WrapFun_;
    it('positive 1', function(kont) {
      return (F_([ty.fun], ty.int, (function(k) {
        return k(null, 0);
      })))(function(err, ans) {
        expect(err != null).to.be(false);
        expect(ans).to.be(0);
        return kont();
      });
    });
    it('positive 2', function(kont) {
      var x;
      x = 314159;
      return (F_([ty.int, ty.fun], ty.int, (function(x, k) {
        return k(null, x);
      })))(x, function(err, ans) {
        expect(err != null).to.be(false);
        expect(ans).to.be(x);
        return kont();
      });
    });
    it('exception', function(kont) {
      return (F_([ty.fun], ty.int, (function(k) {
        return k(new Error('foo'));
      })))(function(err, ans) {
        expect(err != null).to.be.ok();
        expect(err.message).to.be('foo');
        return kont();
      });
    });
    return it('negative', function(kont) {
      expect(function() {
        return F_([ty.fun], ty.int, (function(k) {
          return k(null, 0);
        }))(0);
      }).to.throwError();
      expect(function() {
        return F_([ty.bool, ty.fun], ty.int, (function(k) {
          return k(null, 0);
        }))(0, (function(err, ans) {
          return 0;
        }));
      }).to.throwError();
      return (F_([ty.fun], ty.int, (function(k) {
        return k(null, true);
      })))(function(err, ans) {
        expect(err != null).to.be(true);
        return kont();
      });
    });
  });

  describe('_WrapFun', function(masterkont) {
    var _F;
    _F = ty._WrapFun;
    it('positive 1', function(kont) {
      return (_F([ty.fun], ty.int, (function(k) {
        return k(null, 0);
      })))(function(err, ans) {
        expect(err != null).to.be(false);
        expect(ans).to.be(0);
        return kont();
      });
    });
    it('positive 2', function(kont) {
      var kont2, x;
      x = 314159;
      kont2 = function(err, ans) {
        expect(err != null).to.be(false);
        expect(ans).to.be(x);
        return kont();
      };
      return (_F([ty.fun, ty.int], ty.int, (function(k, x) {
        return k(null, x);
      })))(kont2, x);
    });
    it('exception', function(kont) {
      return (_F([ty.fun], ty.int, (function(k) {
        return k(new Error('foo'));
      })))(function(err, ans) {
        expect(err != null).to.be.ok();
        expect(err.message).to.be('foo');
        return kont();
      });
    });
    return it('negative', function(kont) {
      expect(function() {
        return _F([ty.fun], ty.int, (function(k) {
          return k(null, 0);
        }))(0);
      }).to.throwError();
      expect(function() {
        return _F([ty.fun, ty.bool], ty.int, (function(k) {
          return k(null, 0);
        }))((function(err, ans) {
          return 0;
        }), 0);
      }).to.throwError();
      return (_F([ty.fun], ty.int, (function(k) {
        return k(null, true);
      })))(function(err, ans) {
        expect(err != null).to.be(true);
        return kont();
      });
    });
  });

}).call(this);
